<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voo de Alus - Espiral de Fibonacci</title>
    
    <!-- Three.js - Biblioteca de renderiza√ß√£o 3D baseada em WebGL -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        /* ====================================================================
           ESTILOS CSS - Layout e Interface
           ==================================================================== */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden; /* Evita scroll durante anima√ß√£o */
        }
        
        /* Container principal do canvas 3D */
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        /* Painel de controles - canto superior esquerdo */
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 320px;
            z-index: 100; /* Garante que fica sobre o canvas */
        }
        
        h1 {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #667eea;
            text-align: center;
        }
        
        /* Agrupamento de controles individuais */
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
            font-size: 0.9em;
        }
        
        /* Sliders de configura√ß√£o */
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        /* Display de valores dos sliders */
        .value-display {
            text-align: right;
            color: #667eea;
            font-size: 0.85em;
            font-weight: bold;
        }
        
        /* Estiliza√ß√£o base dos bot√µes */
        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        /* Bot√£o Play/Pause */
        #playPause {
            background: #667eea;
            color: white;
        }
        
        #playPause:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        /* Bot√£o Reset */
        #reset {
            background: #f093fb;
            color: white;
        }
        
        #reset:hover {
            background: #e082ea;
            transform: translateY(-2px);
        }
        
        /* Container para bot√µes de dire√ß√£o */
        .direction-buttons {
            display: flex;
            gap: 10px;
        }
        
        .direction-buttons button {
            flex: 1;
        }
        
        /* Bot√µes de dire√ß√£o - esquerda e direita */
        .btn-left {
            background: #4facfe;
            color: white;
        }
        
        .btn-right {
            background: #00f2fe;
            color: white;
        }
        
        .btn-left:hover {
            background: #3d9be8;
        }
        
        .btn-right:hover {
            background: #00d9e8;
        }
        
        /* Indicador visual de bot√£o ativo */
        .btn-active {
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.5);
        }
        
        /* Painel de informa√ß√µes - canto inferior direito */
        #info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            font-size: 0.9em;
            color: #333;
        }
        
        .info-line {
            margin: 5px 0;
        }
        
        .info-label {
            font-weight: 600;
            color: #667eea;
        }
    </style>
</head>
<body>
    <!-- Container onde ser√° renderizado o canvas 3D -->
    <div id="canvas-container"></div>
    
    <!-- Painel de controles interativos -->
    <div id="controls">
        <h1>ü¶Ö Voo de Alus</h1>
        
        <!-- Controle: N√∫mero de ciclos de Fibonacci -->
        <div class="control-group">
            <label>Ciclos de Fibonacci: <span class="value-display" id="cyclesValue">75</span></label>
            <input type="range" id="cycles" min="50" max="100" value="75" step="1">
        </div>
        
        <!-- Controle: Velocidade da anima√ß√£o -->
        <div class="control-group">
            <label>Velocidade: <span class="value-display" id="speedValue">1.0x</span></label>
            <input type="range" id="speed" min="0.1" max="3" value="1" step="0.1">
        </div>
        
        <!-- Controle: Altura m√°xima do voo -->
        <div class="control-group">
            <label>Altura M√°xima: <span class="value-display" id="heightValue">50</span></label>
            <input type="range" id="maxHeight" min="30" max="100" value="50" step="5">
        </div>
        
        <!-- Controle: Dire√ß√£o do giro (limita√ß√£o de Alus) -->
        <div class="control-group">
            <label>Dire√ß√£o do Giro:</label>
            <div class="direction-buttons">
                <button class="btn-left btn-active" id="leftBtn">‚¨ÖÔ∏è Esquerda</button>
                <button class="btn-right" id="rightBtn">Direita ‚û°Ô∏è</button>
            </div>
        </div>
        
        <!-- Bot√µes de controle da anima√ß√£o -->
        <button id="playPause">‚è∏Ô∏è Pausar</button>
        <button id="reset">üîÑ Resetar</button>
    </div>
    
    <!-- Painel de informa√ß√µes em tempo real -->
    <div id="info">
        <div class="info-line"><span class="info-label">Altitude:</span> <span id="altitude">0.0</span> m</div>
        <div class="info-line"><span class="info-label">Progresso:</span> <span id="progress">0</span>%</div>
        <div class="info-line"><span class="info-label">Raio Atual:</span> <span id="radius">0.0</span> m</div>
    </div>

    <script>
        /* ====================================================================
           JAVASCRIPT - L√ìGICA DA APLICA√á√ÉO
           ==================================================================== */
        
        /* ====================================================================
           1. CONSTANTES E VARI√ÅVEIS GLOBAIS
           ==================================================================== */
        
        // Propor√ß√£o √Åurea (Golden Ratio)
        // œÜ = (1 + ‚àö5) / 2 ‚âà 1.618033988749895
        // Usada para criar crescimento natural da espiral
        const PHI = 1.618033988749895;
        
        // Vari√°veis de configura√ß√£o do voo
        let numCycles = 75;           // N√∫mero de ciclos completos da espiral (50-100)
        let maxHeight = 50;           // Altura m√°xima atingida no meio do voo
        let animationSpeed = 1.0;     // Multiplicador de velocidade (0.1-3.0)
        let direction = -1;           // Dire√ß√£o do giro: -1 = esquerda, 1 = direita
        
        /* ====================================================================
           2. CONFIGURA√á√ÉO DA CENA THREE.JS
           ==================================================================== */
        
        // Criar cena 3D (container para todos os objetos)
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e); // Fundo azul escuro
        scene.fog = new THREE.Fog(0x1a1a2e, 50, 200); // N√©voa para profundidade
        
        // Configurar c√¢mera perspectiva
        // Par√¢metros: FOV (60¬∞), aspect ratio, near plane (0.1), far plane (1000)
        const camera = new THREE.PerspectiveCamera(
            60, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        camera.position.set(50, 40, 50); // Posi√ß√£o inicial da c√¢mera
        camera.lookAt(0, 25, 0);         // Olha para o centro da trajet√≥ria
        
        // Criar renderizador WebGL
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        /* ====================================================================
           3. SISTEMA DE ILUMINA√á√ÉO
           ==================================================================== */
        
        // Luz ambiente - ilumina todos os objetos uniformemente
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        // Luz direcional - simula luz solar
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        scene.add(directionalLight);
        
        // Luz pontual - cria destaque no centro
        const pointLight = new THREE.PointLight(0x667eea, 1, 100);
        pointLight.position.set(0, 50, 0);
        scene.add(pointLight);
        
        /* ====================================================================
           4. VARI√ÅVEIS DE CONTROLE DA ANIMA√á√ÉO
           ==================================================================== */
        
        let trajectoryLine;        // Objeto Three.js com a linha da trajet√≥ria
        let alusBird;             // Modelo 3D do p√°ssaro Alus
        let trajectoryPoints = []; // Array de pontos da espiral
        let currentPosition = 0;   // Posi√ß√£o atual na trajet√≥ria (dist√¢ncia percorrida)
        let isPlaying = true;     // Estado da anima√ß√£o (pausado/rodando)
        let totalDistance = 0;    // Dist√¢ncia total da trajet√≥ria
        let distances = [];       // Array de dist√¢ncias acumuladas (para velocidade constante)
        
        /* ====================================================================
           5. FUN√á√ÉO: CRIAR TRAJET√ìRIA DA ESPIRAL DE FIBONACCI
           ==================================================================== */
        
        /**
         * Gera a trajet√≥ria 3D de Alus baseada na sequ√™ncia de Fibonacci
         * e na propor√ß√£o √°urea. Retorna uma curva suave CatmullRom.
         * 
         * Algoritmo:
         * 1. Gera pontos discretos seguindo espiral de Fibonacci
         * 2. Calcula dist√¢ncias acumuladas entre pontos
         * 3. Cria curva suave interpolada (C¬≤ cont√≠nua)
         * 4. Aplica gradiente de cores baseado na altura
         * 
         * @returns {THREE.CatmullRomCurve3} Curva suave da trajet√≥ria
         */
        function createTrajectory() {
            // Resetar arrays
            trajectoryPoints = [];
            distances = [];
            totalDistance = 0;
            
            const points = [];
            let prevPoint = null;
            
            // Gerar pontos da espiral
            for (let i = 0; i <= numCycles; i++) {
                // Par√¢metro normalizado: t ‚àà [0, 1]
                const t = i / numCycles;
                
                /* RAIO: Crescimento baseado em Fibonacci
                 * - fibIndex mapeia progresso para √≠ndice discreto (0-20)
                 * - œÜ^(fibIndex/5) cria crescimento exponencial suavizado
                 * - Divis√£o por 5 desacelera crescimento
                 * - Multiplica√ß√£o por 2 ajusta escala visual
                 */
                const fibIndex = Math.floor(t * 20);
                const radius = (PHI ** (fibIndex / 5)) * 2;
                
                /* √ÇNGULO: Incremento proporcional √† propor√ß√£o √°urea
                 * - 2œÄ * œÜ * i cria padr√£o n√£o-peri√≥dico
                 * - direction (-1 ou 1) inverte sentido do giro
                 * - Cada ciclo gira aproximadamente 2œÄ * 1.618 ‚âà 10.16 radianos
                 */
                const angle = direction * (2 * Math.PI * PHI * i);
                
                /* ALTURA: Perfil de subida e descida linear
                 * - Primeira metade (t ‚â§ 0.5): subida linear at√© maxHeight
                 * - Segunda metade (t > 0.5): descida linear at√© 0
                 * - Taxa de subida/descida constante = maxHeight / (numCycles/2)
                 */
                let height;
                if (t <= 0.5) {
                    // Fase de subida: y = 2t * h_max
                    height = (t * 2) * maxHeight;
                } else {
                    // Fase de descida: y = (2 - 2t) * h_max
                    height = (2 - t * 2) * maxHeight;
                }
                
                /* CONVERS√ÉO: Coordenadas cil√≠ndricas ‚Üí cartesianas
                 * Cil√≠ndricas: (r, Œ∏, y)
                 * Cartesianas: (x, y, z)
                 * x = r * cos(Œ∏)
                 * z = r * sin(Œ∏)
                 * y = y (altura se mant√©m)
                 */
                const x = radius * Math.cos(angle);
                const z = radius * Math.sin(angle);
                const y = height;
                
                const point = new THREE.Vector3(x, y, z);
                points.push(point);
                
                /* C√ÅLCULO DE DIST√ÇNCIAS ACUMULADAS
                 * Necess√°rio para movimento com velocidade constante.
                 * Armazena dist√¢ncia total percorrida at√© cada ponto.
                 */
                if (prevPoint) {
                    const dist = prevPoint.distanceTo(point);
                    totalDistance += dist;
                    distances.push(totalDistance);
                } else {
                    distances.push(0); // Primeiro ponto: dist√¢ncia = 0
                }
                prevPoint = point;
            }
            
            trajectoryPoints = points;
            
            /* CRIAR CURVA SUAVE (CATMULL-ROM SPLINE)
             * - Passa por todos os pontos de controle
             * - Garante continuidade C¬≤ (curvatura cont√≠nua)
             * - Tension = 0.5 balanceia suavidade e fidelidade aos pontos
             */
            const curve = new THREE.CatmullRomCurve3(points);
            curve.tension = 0.5;
            
            /* INTERPOLA√á√ÉO PARA RENDERIZA√á√ÉO SUAVE
             * Gera 10x mais pontos que ciclos originais para linha suave
             * numCycles * 10 pontos evita segmentos vis√≠veis na linha
             */
            const curvePoints = curve.getPoints(numCycles * 10);
            
            /* APLICAR GRADIENTE DE COR
             * Cores variam do in√≠cio (azul) ao fim (verde)
             * Representa progresso e altitude visualmente
             */
            const colors = [];
            const geometry = new THREE.BufferGeometry().setFromPoints(curvePoints);
            
            for (let i = 0; i < curvePoints.length; i++) {
                const t = i / curvePoints.length;
                const color = new THREE.Color();
                
                // HSL: Hue varia de 0.6 (azul) a 0.3 (verde)
                // Saturation = 1.0 (cores vivas)
                // Lightness aumenta levemente no final
                color.setHSL(0.6 - t * 0.3, 1.0, 0.5 + t * 0.2);
                colors.push(color.r, color.g, color.b);
            }
            
            // Adicionar cores como atributo da geometria
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            // Material que usa cores por v√©rtice
            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                linewidth: 2
            });
            
            // Remover linha antiga se existir
            if (trajectoryLine) scene.remove(trajectoryLine);
            
            // Criar e adicionar nova linha √† cena
            trajectoryLine = new THREE.Line(geometry, material);
            scene.add(trajectoryLine);
            
            return curve;
        }
        
        /* ====================================================================
           6. FUN√á√ÉO: CRIAR MODELO 3D DE ALUS
           ==================================================================== */
        
        /**
         * Constr√≥i o modelo 3D do p√°ssaro Alus usando geometrias primitivas.
         * Componentes: corpo, cabe√ßa, bico, asas, olhos e luz.
         * 
         * @returns {THREE.Group} Grupo contendo todos os componentes do p√°ssaro
         */
        function createAlus() {
            const birdGroup = new THREE.Group();
            
            /* CORPO: Esfera achatada (elipsoide)
             * Scale: (1, 0.8, 1.2) ‚Üí achatado verticalmente, alongado no eixo Z
             */
            const bodyGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            bodyGeometry.scale(1, 0.8, 1.2);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0xffd700,  // Dourado
                shininess: 100    // Brilho especular
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            birdGroup.add(body);
            
            /* CABE√áA: Esfera menor posicionada √† frente
             * Offset: (0, 0.5, 0.8) ‚Üí acima e √† frente do corpo
             */
            const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.set(0, 0.5, 0.8);
            birdGroup.add(head);
            
            /* BICO: Cone rotacionado
             * Rotation.x = œÄ/2 ‚Üí aponta para frente (dire√ß√£o +Z)
             */
            const beakGeometry = new THREE.ConeGeometry(0.15, 0.4, 8);
            const beakMaterial = new THREE.MeshPhongMaterial({ color: 0xff6600 });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.position.set(0, 0.5, 1.2);
            beak.rotation.x = Math.PI / 2;
            birdGroup.add(beak);
            
            /* ASAS: Esferas achatadas e rotacionadas
             * Scale: (2, 0.2, 1) ‚Üí muito alongadas lateralmente, finas
             * Rota√ß√£o.z: ¬±0.3 rad ‚Üí ligeiramente para cima
             */
            const wingGeometry = new THREE.SphereGeometry(0.6, 16, 16);
            wingGeometry.scale(2, 0.2, 1);
            const wingMaterial = new THREE.MeshPhongMaterial({
                color: 0xffec8b,  // Dourado claro
                shininess: 80
            });
            
            // Asa esquerda
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-1, 0, 0);
            leftWing.rotation.z = -0.3;
            birdGroup.add(leftWing);
            
            // Asa direita
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(1, 0, 0);
            rightWing.rotation.z = 0.3;
            birdGroup.add(rightWing);
            
            /* OLHOS: Pequenas esferas pretas
             * Posicionados simetricamente na cabe√ßa
             */
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.2, 0.6, 1.1);
            birdGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.2, 0.6, 1.1);
            birdGroup.add(rightEye);
            
            /* LUZ PONTUAL: Ilumina √°rea ao redor de Alus
             * Cria efeito de "aura" dourada seguindo o p√°ssaro
             */
            const birdLight = new THREE.PointLight(0xffd700, 1, 10);
            birdGroup.add(birdLight);
            
            return birdGroup;
        }
        
        /* ====================================================================
           7. INICIALIZA√á√ÉO
           ==================================================================== */
        
        // Criar trajet√≥ria inicial
        let curve = createTrajectory();
        
        // Criar e adicionar Alus √† cena
        alusBird = createAlus();
        scene.add(alusBird);
        
        // Adicionar grade de refer√™ncia no ch√£o
        // Par√¢metros: tamanho (150), divis√µes (30), cor central, cor da grade
        const gridHelper = new THREE.GridHelper(150, 30, 0x444444, 0x222222);
        scene.add(gridHelper);
        
        /* ====================================================================
           8. EVENT LISTENERS - CONTROLES INTERATIVOS
           ==================================================================== */
        
        /**
         * Controle: N√∫mero de ciclos de Fibonacci
         * Regenera trajet√≥ria quando alterado
         */
        document.getElementById('cycles').addEventListener('input', (e) => {
            numCycles = parseInt(e.target.value);
            document.getElementById('cyclesValue').textContent = numCycles;
            curve = createTrajectory(); // Recalcular trajet√≥ria
            currentPosition = 0;        // Resetar posi√ß√£o
        });
        
        /**
         * Controle: Velocidade da anima√ß√£o
         * Atualiza multiplicador sem regenerar trajet√≥ria
         */
        document.getElementById('speed').addEventListener('input', (e) => {
            animationSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = animationSpeed.toFixed(1) + 'x';
        });
        
        /**
         * Controle: Altura m√°xima do voo
         * Regenera trajet√≥ria com novo perfil vertical
         */
        document.getElementById('maxHeight').addEventListener('input', (e) => {
            maxHeight = parseFloat(e.target.value);
            document.getElementById('heightValue').textContent = maxHeight;
            curve = createTrajectory();
            currentPosition = 0;
        });
        
        /**
         * Controle: Dire√ß√£o esquerda
         * Define direction = -1 e regenera trajet√≥ria espelhada
         */
        document.getElementById('leftBtn').addEventListener('click', () => {
            direction = -1;
            document.getElementById('leftBtn').classList.add('btn-active');
            document.getElementById('rightBtn').classList.remove('btn-active');
            curve = createTrajectory();
            currentPosition = 0;
        });
        
        /**
         * Controle: Dire√ß√£o direita
         * Define direction = 1 e regenera trajet√≥ria espelhada
         */
        document.getElementById('rightBtn').addEventListener('click', () => {
            direction = 1;
            document.getElementById('rightBtn').classList.add('btn-active');
            document.getElementById('leftBtn').classList.remove('btn-active');
            curve = createTrajectory();
            currentPosition = 0;
        });
        
        /**
         * Controle: Play/Pause
         * Alterna estado da anima√ß√£o sem perder progresso
         */
        document.getElementById('playPause').addEventListener('click', () => {
            isPlaying = !isPlaying;
            document.getElementById('playPause').textContent = isPlaying ? '‚è∏Ô∏è Pausar' : '‚ñ∂Ô∏è Continuar';
        });
        
        /**
         * Controle: Reset
         * Reinicia anima√ß√£o do in√≠cio
         */
        document.getElementById('reset').addEventListener('click', () => {
            currentPosition = 0;
            isPlaying = true;
            document.getElementById('playPause').textContent = '‚è∏Ô∏è Pausar';
        });
        
        /* ====================================================================
           9. LOOP DE ANIMA√á√ÉO PRINCIPAL
           ==================================================================== */
        
        /**
         * Fun√ß√£o de anima√ß√£o executada a ~60 FPS (via requestAnimationFrame)
         * 
         * Responsabilidades:
         * 1. Atualizar posi√ß√£o de Alus com velocidade constante
         * 2. Orientar Alus na dire√ß√£o do movimento
         * 3. Animar asas batendo
         * 4. Atualizar display de informa√ß√µes
         * 5. Rotacionar c√¢mera automaticamente
         * 6. Renderizar frame
         */
        function animate() {
            requestAnimationFrame(animate); // Agendar pr√≥ximo frame
            
            if (isPlaying) {
                /* MOVIMENTO COM VELOCIDADE CONSTANTE
                 * Incremento baseado em dist√¢ncia, n√£o em par√¢metro t
                 * F√≥rmula: Œîs = (0.002 * speed * L_total) / n_cycles
                 * 
                 * - 0.002: Constante de calibra√ß√£o (ajustada empiricamente)
                 * - animationSpeed: Multiplicador do usu√°rio (0.1-3.0)
                 * - totalDistance: Comprimento total da curva
                 * - numCycles: Normaliza por n√∫mero de voltas
                 */
                const increment = (0.002 * animationSpeed * totalDistance) / numCycles;
                currentPosition += increment;
                
                // Loop: volta ao in√≠cio quando completa trajet√≥ria
                if (currentPosition >= totalDistance) {
                    currentPosition = 0;
                }
                
                /* ENCONTRAR √çNDICE NA TRAJET√ìRIA
                 * Busca bin√°ria manual: qual segmento cont√©m currentPosition?
                 * distances[i] ‚â§ currentPosition < distances[i+1]
                 */
                let targetIndex = 0;
                for (let i = 0; i < distances.length - 1; i++) {
                    if (currentPosition >= distances[i] && currentPosition < distances[i + 1]) {
                        targetIndex = i;
                        break;
                    }
                }
                
                // Converter √≠ndice para par√¢metro t da curva
                const t = targetIndex / (trajectoryPoints.length - 1);
                
                // Obter posi√ß√£o 3D na curva
                const position = curve.getPoint(t);
                alusBird.position.copy(position);
                
                /* ORIENTAR ALUS NA DIRE√á√ÉO DO MOVIMENTO
                 * getTangent(t): vetor dire√ß√£o da curva no ponto t
                 * lookAt(): rotaciona objeto para olhar em dire√ß√£o ao ponto
                 */
                const tangent = curve.getTangent(t);
                const lookAtPos = position.clone().add(tangent);
                alusBird.lookAt(lookAtPos);
                
                /* ANIMAR BATER DE ASAS
                 * Movimento senoidal: sen(œât) com œâ = 0.01 rad/ms
                 * Amplitude: ¬±0.3 radianos (‚âà ¬±17¬∞)
                 * children[3] e [4] s√£o as asas (√≠ndices fixos)
                 */
                const wingFlap = Math.sin(Date.now() * 0.01) * 0.3;
                alusBird.children[3].rotation.z = -0.3 + wingFlap; // Asa esquerda
                alusBird.children[4].rotation.z = 0.3 - wingFlap;  // Asa direita
                
                /* ATUALIZAR DISPLAY DE INFORMA√á√ïES
                 * - Altitude: posi√ß√£o Y atual
                 * - Progresso: % da dist√¢ncia total percorrida
                 * - Raio: dist√¢ncia ao eixo Y (‚àö(x¬≤ + z¬≤))
                 */
                document.getElementById('altitude').textContent = position.y.toFixed(1);
                document.getElementById('progress').textContent = Math.round((currentPosition / totalDistance) * 100);
                
                const radius = Math.sqrt(position.x ** 2 + position.z ** 2);
                document.getElementById('radius').textContent = radius.toFixed(1);
            }
            
            /* ROTA√á√ÉO AUTOM√ÅTICA DA C√ÇMERA
             * Movimento circular em torno do centro
             * Velocidade: 0.0001 rad/ms (um ciclo completo em ~10 minutos)
             * Raio: 60 unidades, altura fixa Y=40
             */
            const time = Date.now() * 0.0001;
            camera.position.x = Math.cos(time) * 60;
            camera.position.z = Math.sin(time) * 60;
            camera.lookAt(0, 25, 0); // Sempre olha para centro vertical
            
            // RENDERIZAR FRAME
            renderer.render(scene, camera);
        }
        
        /* ====================================================================
           10. RESPONSIVIDADE
           ==================================================================== */
        
        /**
         * Atualiza aspect ratio e dimens√µes do canvas quando janela √© redimensionada
         */
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); // Recalcular matriz de proje√ß√£o
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        /* ====================================================================
           11. INICIAR ANIMA√á√ÉO
           ==================================================================== */
        
        animate(); // Kickstart do loop de anima√ß√£o
        
    </script>
</body>
</html>