

export class RevolutionSurface {
    /**
     
     * @param {Array} profile 
     * @param {string} axis
     * @param {number} angle 
     * @param {number} angularDivisions 
     * @returns {Object}
     */
    static generate(profile, axis = 'y', angle = 360, angularDivisions = 32) {
        const vertices = [];
        const faces = [];
        const normals = [];
        
        const angleRad = (angle * Math.PI) / 180;
        const angleStep = angleRad / angularDivisions;
        
        
        for (let i = 0; i <= angularDivisions; i++) {
            const theta = i * angleStep;
            const cos = Math.cos(theta);
            const sin = Math.sin(theta);
            
            for (let j = 0; j < profile.length; j++) {
                const point = profile[j];
                let vertex;
                
                switch(axis) {
                    case 'x':
                        vertex = [point.y, point.x * cos, point.x * sin];
                        break;
                    case 'z':
                        vertex = [point.x * cos, point.y, point.x * sin];
                        break;
                    default: 
                        vertex = [point.x * cos, point.y, point.x * sin];
                }
                
                vertices.push(vertex);
            }
        }
        
       
        const profileLength = profile.length;
        for (let i = 0; i < angularDivisions; i++) {
            for (let j = 0; j < profileLength - 1; j++) {
                const idx1 = i * profileLength + j;
                const idx2 = i * profileLength + j + 1;
                const idx3 = (i + 1) * profileLength + j + 1;
                const idx4 = (i + 1) * profileLength + j;
                
                faces.push([idx1, idx2, idx3]);
                faces.push([idx1, idx3, idx4]);
                
             
                const v1 = vertices[idx1];
                const v2 = vertices[idx2];
                const v3 = vertices[idx3];
                
                const normal = this.calculateNormal(v1, v2, v3);
                normals.push(normal);
            }
        }
        
        return { vertices, faces, normals };
    }
    

    static calculateNormal(v1, v2, v3) {
        const ux = v2[0] - v1[0], uy = v2[1] - v1[1], uz = v2[2] - v1[2];
        const vx = v3[0] - v1[0], vy = v3[1] - v1[1], vz = v3[2] - v1[2];
        
        const nx = uy * vz - uz * vy;
        const ny = uz * vx - ux * vz;
        const nz = ux * vy - uy * vx;
        
        const length = Math.sqrt(nx * nx + ny * ny + nz * nz);
        return length > 0 ? [nx / length, ny / length, nz / length] : [0, 1, 0];
    }
    
    
    static exportOBJ(geometry) {
        let obj = '# Generated by Revolution Surface\n\n';
        
        geometry.vertices.forEach(v => {
            obj += `v ${v[0].toFixed(6)} ${v[1].toFixed(6)} ${v[2].toFixed(6)}\n`;
        });
        
        obj += '\n';
        
        geometry.faces.forEach(f => {
            obj += `f ${f[0] + 1} ${f[1] + 1} ${f[2] + 1}\n`;
        });
        
        return obj;
    }
    
    
    static exportSTL(geometry) {
        let stl = 'solid RevolutionSurface\n';
        
        geometry.faces.forEach((f, idx) => {
            const v1 = geometry.vertices[f[0]];
            const v2 = geometry.vertices[f[1]];
            const v3 = geometry.vertices[f[2]];
            const n = geometry.normals[Math.floor(idx / 2)] || [0, 1, 0];
            
            stl += `  facet normal ${n[0].toFixed(6)} ${n[1].toFixed(6)} ${n[2].toFixed(6)}\n`;
            stl += `    outer loop\n`;
            stl += `      vertex ${v1[0].toFixed(6)} ${v1[1].toFixed(6)} ${v1[2].toFixed(6)}\n`;
            stl += `      vertex ${v2[0].toFixed(6)} ${v2[1].toFixed(6)} ${v2[2].toFixed(6)}\n`;
            stl += `      vertex ${v3[0].toFixed(6)} ${v3[1].toFixed(6)} ${v3[2].toFixed(6)}\n`;
            stl += `    endloop\n`;
            stl += `  endfacet\n`;
        });
        
        stl += 'endsolid RevolutionSurface\n';
        return stl;
    }
}